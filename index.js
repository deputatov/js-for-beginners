'use strict'
/*
При помощи явного приведения типов используя объект обертку Number или согласно
правилу https://tc39.es/ecma262/#sec-unary-plus-operator используя унарный "+" плюс
*/
const a = '1';
Number(a) + 1 === 2
+ a + 1 === 2

/*
Cпецификации для реляционных операторов находятся тут https://tc39.es/ecma262/#sec-relational-operators
*/
5 > 4 === true


/*
Строки в языке JS согласно спецификации сравниваются посимвольно сравнивается при этом коды этих символов
Если код первого символа первой строки больше (меньше), чем код первого символа второй, то первая строка больше (меньше) второй. Сравнение завершено.
Если коды первых символов равны, то таким же образом сравниваются уже вторые символы строк.
Сравнение продолжается, пока не закончится одна из строк.
Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
*/
"ананас" > "яблоко" === true
"2" > "12" === true


/*
Согласно правилу спецификации https://tc39.es/ecma262/#sec-isstrictlyequal
псевдооператор строгого сравнения IsStrictlyEqual принимает 2 аргумента,
если типы этих аргументов различны то возвращается false
*/
undefined === null === false
null === +"\n0\n" === false


null == "\n0\n" === false
undefined == null === true
/* 
В данном примере используется оператор нестрогого равенства, согласно правилу
описанному в спецификации => https://tc39.es/ecma262/#sec-equality-operators-runtime-semantics-evaluation
в данном выражении используется при сравнении абстрактный оператор
isLooselyEqual => https://tc39.es/ecma262/#sec-islooselyequal
согласно пунктам 2 и 3 данного правила следует нижеописанное
2. If x is null and y is undefined, return true.
3. If x is undefined and y is null, return true.
Вот почему только null == undefined в остальных случаях false
*/